'use strict'
/**
 * Capture live motion vectors generated by encoding video coming from 
 * a connected sensor.
 * 
 * 20-may-2020, Joakim Romland
 */


const MvrFilterFlags = {
	MAGNITUDE_LT_300 : 1,
	DX_DY_LT_2 : 2,
	FRAME_MAGNITUDE_400_INCREASE : 4,
	NO_SAD : 8,
}

class MvrProcessor
{
	/*
		Class scope variables
			this.stats
			this.mv (for pre-alloc purposes only)
			this.resolutionWidth
			this.resolutionHeight
			this.fps
			this.startTime
	*/
	constructor(fps, resolutionWidth, resolutionHeight)
	{
		this.stats = {
			frameCount : 0,
			flashes : 0,
			ignored : 0,
			previousFrameMagTotal : 0,
			motionFlashes : 0,
			ignoredFrames : 0,
		};

		this.mv = {
			dx : null,
			dy : null,
			sad : null,

			dir : null,
			mag : null
		};

		this.resolutionWidth = resolutionWidth;
		this.resolutionHeight = resolutionHeight;
		this.fps = fps;
		this.startTime = Date.now();
	}


	getFrameSize()
	{
		return ((Math.floor(this.resolutionHeight / 16) + 1) * (Math.floor(this.resolutionWidth / 16) + 1) * 4);
	}

	getMotionVectorAt(buffer, index, outMv)
	{
		outMv.dx = buffer.readIntLE(index + 0, 1);
		outMv.dy = buffer.readIntLE(index + 1, 1);
		outMv.sad = buffer.readIntLE(index + 2, 2);

		// Angle
		outMv.dir = Math.atan2(outMv.dy, -outMv.dx) * 180 / Math.PI + 180;

		// Magnitude (Pythagoras) -- TODO: could just use Manhattan distance? (cheaper)
		outMv.mag = Math.sqrt(outMv.dx * outMv.dx + outMv.dy * outMv.dy);

		return outMv;
	}

	outputFrameStats(frameData)
	{
		let frameLength = this.getFrameSize();

		// To check ranges of the data to figure out savings...
		let maxDx = -1000000;
		let minDx = 1000000;
		let totDx = 0;

		let maxDy = -1000000;
		let minDy = 1000000;
		let totDy = 0;

		let maxSad = -1000000;
		let minSad = 1000000;
		let totSad = 0;

		let maxMag = -1000000;
		let minMag = 1000000;
		let totMag = 0;

		let maxDir = -1000000;
		let minDir = 1000000;
		let totDir = 0;

		let i = 0;

		let mv = this.mv;
		let ts = null;
		let vectorsPerFrame = this.getFrameSize();

		while(i < frameLength) {
			this.getMotionVectorAt(frameData, i, mv);

			//
			// Gather some stats on what data we are getting here...
			//
			if(mv.dx > maxDx) maxDx = mv.dx;
			if(mv.dx < minDx) minDx = mv.dx;
			totDx += mv.dx;

			if(mv.dy > maxDy) maxDy = mv.dy;
			if(mv.dy < minDy) minDy = mv.dy;
			totDy += mv.dy;

			if(mv.sad > maxSad) maxSad = mv.sad;
			if(mv.sad < minSad) minSad = mv.sad;
			totSad += mv.sad;

			if(mv.mag > maxMag) maxMag = mv.mag;
			if(mv.mag < minMag) minMag = mv.mag;
			totMag += mv.mag;

			if(mv.dir > maxDir) maxDir = mv.dir;
			if(mv.dir < minDir) minDir = mv.dir;
			totDir += mv.dir;

			i += 4;
		}

		ts = ((Date.now() - this.startTime) / 1000);

		let out = ""
			+ "ts: " + Math.round(ts)
			+ "\tfps: " + Math.ceil(this.stats.frameCount / ts)
			+ "\tframe: " + this.stats.frameCount
			+ "\tdx: " + minDx +	" - " + maxDx + ` (${Math.round(totDx / vectorsPerFrame)})`
			+ "\tdy: " + minDy +	" - " + maxDy + ` (${Math.round(totDy / vectorsPerFrame)})`
			+ "\n"
			+ "dir: " + Math.round(minDir) +	"-" + Math.round(maxDir) + ` (${Math.round(totDir / vectorsPerFrame)})`
			+ "\n"
			+ "\tmag: " + minMag +	"-" + Math.round(maxMag) + ` (frame tot: ${Math.round(totMag)} vec avg: ${Math.round(totMag / vectorsPerFrame)})`
			+ "\n"
			+ "\tflashes: " + this.stats.motionFlashes
			+ "\tignored: " + this.stats.ignoredFrames
			+ "\tsad: " + minSad +	"-" + maxSad + ` (${Math.round(totSad / vectorsPerFrame)})`;

		console.clear();
		console.log(out);
		//Log.info(out);
	}


	/**
	 * This is the important one.
	 * This is the one that modifies source data.
	 * 
	 * This is where we want to remove as little as possible yet reduce size as much 
	 * as possible, use statistics to figure out what is useful and useless.
	 */
	processFrame(frameData, filterFlags)
	{
		let i = 0;
		let totMag = 0;
		let previousFrameMagTotal = 0;
		let frameLength = this.getFrameSize();

		// Default filter flags
		if(!filterFlags) {
			filterFlags = MvrFilterFlags.DX_DY_LT_2 | MvrFilterFlags.FRAME_MAGNITUDE_400_INCREASE | MvrFilterFlags.MAGNITUDE_LT_300;
		}

		while(i < frameLength) {
			this.getMotionVectorAt(frameData, i, this.mv);

			if((filterFlags & MvrFilterFlags.DX_DY_LT_2) === MvrFilterFlags.DX_DY_LT_2) {
				// 0x01
				if(Math.abs(this.mv.dx) < 2 && Math.abs(this.mv.dy) < 2) {
					// Zero out this complete vector
					frameData.writeInt32LE(0, i); // WARNING: Changes the dataset!
					this.mv.dx = 0;
					this.mv.dy = 0;
					this.mv.sad = 0;
					this.mv.dir = 0;
					this.mv.mag = 0;
				}
			}

			if((filterFlags & MvrFilterFlags.NO_SAD) === MvrFilterFlags.NO_SAD) {
				// 0x02: zero out SAD of the vector
				frameData.writeInt16LE(0, i+2); // WARNING: Changes the dataset!
			}

			totMag += this.mv.mag;
			i += 4;
		} // each vector

		if((filterFlags & MvrFilterFlags.FRAME_MAGNITUDE_400_INCREASE) === MvrFilterFlags.FRAME_MAGNITUDE_400_INCREASE) {
			// 400% increase in motion compared to last frame -- get this from encoder sometimes 
			// (is it camera? something else? what do these vectors look like?)
			// I see similarities to a SAD rendering in these flashes -- can I use that as a 
			// template to figure out whether to filter?
			if(previousFrameMagTotal > 0 && totMag > (previousFrameMagTotal * 4)) {
				// A motion flash!
				this.stats.motionFlashes++;
				
				//Log.info("FLASH! motion flash, exiting to investigate what the hell these vectors are!");
				//return;

				// Zero out frames that are motion-flashes [flash-rem in compression results]
				frameData.fill(0);	// WARNING: Changes the dataset!
			}
			// -- flash check
		}
		
		if((filterFlags & MvrFilterFlags.MAGNITUDE_LT_300) === MvrFilterFlags.MAGNITUDE_LT_300) {
			// Check total magnitude of frame, if low, zero it
			// This is by no means a number I have come to with a lot of research,
			// so tweak/verify to hearts content!
			if(totMag < 300) {
				this.stats.ignoredFrames++;
				frameData.fill(0);	// WARNING: Changes the dataset!
			}
		}

		previousFrameMagTotal = totMag;
		this.stats.frameCount++;
	} // processFrame

}

exports.default = MvrProcessor;
exports.MvrFilterFlags = MvrFilterFlags;
