'use strict'
/**
 * Capture live motion vectors generated by encoding video coming from 
 * a connected sensor.
 * 
 * 20-may-2020, Joakim Romland
 */

const jdbscan = require("./jdbscan");


const MvrFilterFlags = {
	MAGNITUDE_LT_300 : 1,
	DX_DY_LT_2 : 2,
	FRAME_MAGNITUDE_400_INCREASE : 4,
	NO_SAD : 8,
}

class MvrProcessor
{
	/*
		Class scope variables
			this.stats
			this.mv (for pre-alloc purposes only)
			this.resolutionWidth
			this.resolutionHeight
			this.fps
			this.startTime
	*/
	constructor(fps, resolutionWidth, resolutionHeight)
	{
		this.stats = {
			frameCount : 0,
			flashes : 0,
			ignored : 0,
			previousFrameMagTotal : 0,
			motionFlashes : 0,
			ignoredFrames : 0,
		};

		this.mv = {
			dx : null,
			dy : null,
			sad : null,

			dir : null,
			mag : null
		};


		this.frameDataHeight = Math.floor( resolutionHeight / 16) + 1;
		this.frameDataWidth = Math.floor( resolutionWidth / 16) + 1;
		this.resolutionWidth = resolutionWidth;
		this.resolutionHeight = resolutionHeight;
		this.fps = fps;
		this.startTime = Date.now();
	}


	getFrameSize()
	{
		return ((Math.floor(this.resolutionHeight / 16) + 1) * (Math.floor(this.resolutionWidth / 16) + 1) * 4);
	}

	getMotionVectorAt(buffer, index, outMv)
	{
		outMv.dx = buffer.readIntLE(index + 0, 1);
		outMv.dy = buffer.readIntLE(index + 1, 1);
		outMv.sad = buffer.readIntLE(index + 2, 2);

		// Angle
		outMv.dir = Math.atan2(outMv.dy, -outMv.dx) * 180 / Math.PI + 180;

		// Magnitude (Pythagoras) -- TODO: could just use Manhattan distance? (cheaper)
		outMv.mag = Math.sqrt(outMv.dx * outMv.dx + outMv.dy * outMv.dy);

		return outMv;
	}

	outputFrameStats(frameData)
	{
		let frameLength = this.getFrameSize();

		// To check ranges of the data to figure out savings...
		let maxDx = -1000000;
		let minDx = 1000000;
		let totDx = 0;

		let maxDy = -1000000;
		let minDy = 1000000;
		let totDy = 0;

		let maxSad = -1000000;
		let minSad = 1000000;
		let totSad = 0;

		let maxMag = -1000000;
		let minMag = 1000000;
		let totMag = 0;

		let maxDir = -1000000;
		let minDir = 1000000;
		let totDir = 0;

		let i = 0;

		let mv = this.mv;
		let ts = null;
		let vectorsPerFrame = this.getFrameSize();

		while(i < frameLength) {
			this.getMotionVectorAt(frameData, i, mv);

			//
			// Gather some stats on what data we are getting here...
			//
			if(mv.dx > maxDx) maxDx = mv.dx;
			if(mv.dx < minDx) minDx = mv.dx;
			totDx += mv.dx;

			if(mv.dy > maxDy) maxDy = mv.dy;
			if(mv.dy < minDy) minDy = mv.dy;
			totDy += mv.dy;

			if(mv.sad > maxSad) maxSad = mv.sad;
			if(mv.sad < minSad) minSad = mv.sad;
			totSad += mv.sad;

			if(mv.mag > maxMag) maxMag = mv.mag;
			if(mv.mag < minMag) minMag = mv.mag;
			totMag += mv.mag;

			if(mv.dir > maxDir) maxDir = mv.dir;
			if(mv.dir < minDir) minDir = mv.dir;
			totDir += mv.dir;

			i += 4;
		}

		ts = ((Date.now() - this.startTime) / 1000);

		let out = ""
			+ "ts: " + Math.round(ts)
			+ "\tfps: " + Math.ceil(this.stats.frameCount / ts)
			+ "\tframe: " + this.stats.frameCount
			+ "\tdx: " + minDx +	" - " + maxDx + ` (${Math.round(totDx / vectorsPerFrame)})`
			+ "\tdy: " + minDy +	" - " + maxDy + ` (${Math.round(totDy / vectorsPerFrame)})`
			+ "\n"
			+ "dir: " + Math.round(minDir) +	"-" + Math.round(maxDir) + ` (${Math.round(totDir / vectorsPerFrame)})`
			+ "\n"
			+ "\tmag: " + minMag +	"-" + Math.round(maxMag) + ` (frame tot: ${Math.round(totMag)} vec avg: ${Math.round(totMag / vectorsPerFrame)})`
			+ "\n"
			+ "\tflashes: " + this.stats.motionFlashes
			+ "\tignored: " + this.stats.ignoredFrames
			+ "\tsad: " + minSad +	"-" + maxSad + ` (${Math.round(totSad / vectorsPerFrame)})`;

		console.clear();
		console.log(out);
		//Log.info(out);
	}


	isMover(buffer, index)
	{
		return Math.max( Math.abs(buffer.readIntLE(index + 0, 1)), Math.abs(buffer.readIntLE(index + 1, 1)) ) > 2;
	}

	isLoner(frameData, index)
	{
		let w4 = this.frameDataWidth * 4;
		let x = Math.floor(index % w4);
		let y = Math.floor(index / w4);
//console.log(index, index - w4, x, y);

		// Above
		if(y > 0 && this.isMover(frameData, index - w4))
			return false;

		// Below
		if(y < (this.frameDataHeight-1) && this.isMover(frameData, index + w4))
			return false;

		// Left
		if(x > 0 && this.isMover(frameData, index - (1 * 4)))
			return false;

		// Right
		if(x < this.frameDataWidth && this.isMover(frameData, index + (1 * 4)))
			return false;

		// TODO: check diagonals

		return true;
	}


	/**
	 * This is the important one.
	 * This is the one that modifies source data.
	 * 
	 * This is where we want to remove as little as possible yet reduce size as much 
	 * as possible, use statistics to figure out what is useful and useless.
	 */
	processFrame(frameData, filterFlags)
	{
		let i = 0;
		let totMag = 0;
		let previousFrameMagTotal = 0;
		let frameLength = this.getFrameSize();
		let loners = [];
		let candidates = [];

		// Default filter flags
		if(!filterFlags) {
			filterFlags = MvrFilterFlags.DX_DY_LT_2 | MvrFilterFlags.FRAME_MAGNITUDE_400_INCREASE | MvrFilterFlags.MAGNITUDE_LT_300;
		}

		while(i < frameLength) {
			this.getMotionVectorAt(frameData, i, this.mv);

			if(true && this.mv.mag >= 2 && this.isLoner(frameData, i)) {
				loners.push(i);
			} else if(this.mv.mag > 10) {
				candidates.push(
					{
						x : Math.floor( (i/4) % this.frameDataWidth),
						y : Math.floor( (i/4) / this.frameDataWidth)
					}
				);
			}

			if((filterFlags & MvrFilterFlags.DX_DY_LT_2) === MvrFilterFlags.DX_DY_LT_2) {
				// 0x01
				if(Math.abs(this.mv.dx) < 2 && Math.abs(this.mv.dy) < 2) {
					// Zero out this complete vector
					frameData.writeInt32LE(0, i); // WARNING: Changes the dataset!
					this.mv.dx = 0;
					this.mv.dy = 0;
					this.mv.sad = 0;
					this.mv.dir = 0;
					this.mv.mag = 0;
				}
			}

			if((filterFlags & MvrFilterFlags.NO_SAD) === MvrFilterFlags.NO_SAD) {
				// 0x02: zero out SAD of the vector
				frameData.writeInt16LE(0, i+2); // WARNING: Changes the dataset!
			}

			totMag += this.mv.mag;
			i += 4;
		} // each vector


		let nullFrame = false;

		if((filterFlags & MvrFilterFlags.FRAME_MAGNITUDE_400_INCREASE) === MvrFilterFlags.FRAME_MAGNITUDE_400_INCREASE) {
			// 400% increase in motion compared to last frame -- get this from encoder sometimes 
			// (is it camera? something else? what do these vectors look like?)
			// I see similarities to a SAD rendering in these flashes -- can I use that as a 
			// template to figure out whether to filter?
			if(previousFrameMagTotal > 0 && totMag > (previousFrameMagTotal * 4)) {
				// A motion flash!
				this.stats.motionFlashes++;
				
				//Log.info("FLASH! motion flash, exiting to investigate what the hell these vectors are!");
				//return;

				// Zero out frames that are motion-flashes [flash-rem in compression results]
				frameData.fill(0);	// WARNING: Changes the dataset!
				nullFrame = true;
			}
			// -- flash check
		}
		
		if((filterFlags & MvrFilterFlags.MAGNITUDE_LT_300) === MvrFilterFlags.MAGNITUDE_LT_300) {
			// Check total magnitude of frame, if low, zero it
			// This is by no means a number I have come to with a lot of research,
			// so tweak/verify to hearts content!
			if(totMag < 300) {
				this.stats.ignoredFrames++;
				frameData.fill(0);	// WARNING: Changes the dataset!
				nullFrame = true;
			}
		}


		let clusters = [];
		if(!nullFrame) {

			for(let i = 0; i < loners.length; i++) {
				// TODO: Decrease totMag equivalent to the vectors we remove
				frameData.writeInt32LE(0, loners[i]); // WARNING: Changes the dataset!
			}

			// =============== clustering
			let dbscanner = jdbscan()
				.eps(1)
				.minPts(8)
				.distance((p1, p2) => {
					return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
				})
				.data(candidates);
			let results = dbscanner();

			let id, cluster;
			for(let i = 0; i < results.length; i++) {
				id = results[i];

				if(results[i] === 0) {
					// cluster 0 is noise?
					continue;
				}

				if(!clusters[id]) {
					clusters[id] = { points : [], /* clockwise from top */ box : [ 1000, 0, 0, 1000 ] };
				}
				cluster = clusters[id];

				cluster.points.push(candidates[i]);

				// Bounding box
				if(candidates[i].y < cluster.box[0]) cluster.box[0] = candidates[i].y;
				if(candidates[i].x > cluster.box[1]) cluster.box[1] = candidates[i].x;
				if(candidates[i].y > cluster.box[2]) cluster.box[2] = candidates[i].y;
				if(candidates[i].x < cluster.box[3]) cluster.box[3] = candidates[i].x;
			}

			if(clusters.length > 0) {
				clusters.splice(0, 1);
			}

			//console.log("loners", loners.length, "candidate points", candidates.length, "clusters", clusters.length, clusters);

/*
			console.log("loners", loners.length, "candidate points", candidates.length, "clusters", clusters.length);

			for(let i = 0; i < clusters.length; i++) {
				console.log("\t", clusters[i].box);
			}
*/

			// ================ /clustering
		} else {
			console.log("nullframe");
		}


		previousFrameMagTotal = totMag;
		this.stats.frameCount++;

		return clusters;
	} // processFrame

}

exports.default = MvrProcessor;
exports.MvrFilterFlags = MvrFilterFlags;
